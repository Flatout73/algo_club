# Порция 1
* базовые типы
 * int, float, str, bool
 * type - узнать тип
 * операции
   * + - / * **
   * << >> & |
   * and or not
* переменные 
 * a=3:
    * завести область памяти в которой лежит 3
    * связать с переменной a
 * a=b работает по-разному:
    * перепривязка переменной a, если тип b сложный
    * перекладывание данных, если в b - простой тип

## задачи
1. поменять местами значения a и b, можно использовать третью переменную
2. поменять a и b местами без третьей переменной
3. посчитать разные выражения: `2*3+4*5   3**2+4**2    5**2  и т.д .`
    
# Порция 2
* Оператор for
  * Пишется: 
      `for переменная in итерабле:
           тело цикла`
    * итерабле - коллекция, или итератор    
  * читается:
    * выполнять "тело цикла", помещая в "переменную" последовательно все значения из "итерабле"
* Оператор while
  * Пишется:
      `while условие:
           тело цикла`
  * Читается:
    * выполнять "тело цикла", пока выполняется "условие".
 
## задачи
1. Распечатать первые 10 степеней двойки
2. Распечатывать степени двойки, пока они меньше 5000
3. Распечатать первые 15 чисел Фибоначчи
4. Распечатывать числа Фибоначчи, пока они меньше 10000
 
# Порция 3

* Оператор if
  * Пишется: 
      `if условие:
           блок1
       else:
           блок2`
  * Это основная форма. Ещё нужно почитать документацию по поводу elif
* Условие: 
  * элементарные условия: a == b, a < b, a <= b
  * правила построения сложных условий
    * усл1 and усл2
    * усл1 or усл2
    * not усл

## задачи
1. Заданы числа a, b - целые, от -10 000 до 10 000. Решить уравнение a*x + b = 0. Если решений нет, или их бесконечно много, сообщить об этом.
2. Заданы числа a, b, c - целые, от -10 000 до 10 000. Решить уравнение a*x**2 + b*x + c = 0. Если решений нет, или их бесконечно много, сообщить об этом.
3. Написать программу, которая распечатывает числа от 1 до 100. Но если число делится на 3 напечатать вместо него "Fizz", "Buzz" - для делящихся на 5. Вместо чисел, делящихся и на 3 и на 5 напечатать "FizzBuzz".
 
# Порция 4
* Арифметические операции
  * + - / // *
* Логические операции
  * & | ^
  
## задачи
1. Посчитать количество 1 в двоичном представлении целого числа
2. Является ли позиция, заданная массивом целых чисел, выигрышной в игре Ним?
3. В массиве натуральных чисел n пар чисел и одно непарное. Найти это непарное число. Числа идут в произвольном порядке.
4. В массиве натуральных чисел n пар чисел и два непарных. Найти эти непарные числа. Числа идут в произвольном порядке.
5. Является ли число степенью двойки?
6. Является ли число степенью четвёрки?

## Циклы, условия, арифметика, логика:

```
import sys
sys.stdout.write('*') - распечатать * без перевода строка
sys.stdout.write('/n') - перевести строку
```
* распечатать 40 *
* распечатать попеременно звёздочки и пробелы: * * * * * ...
* распечатать шахматную доску из звёздочек и пробелов
```
* * * *
 * * * *
....
 ```
* треугольник из звёздочек. 40 строчек
```
*
**
***
****
....
```

* стрелка из звёздочек, количество строчек задаётся переменной n:
```
*
**
***
****
*****
******
*****
****
***
**
*
```

* распечатать квадрат из звёздочек 100 на 100. Номер строки - y, номер столбца - x
* в зависимости от условия распечатывать либо звёздочку, либо пробел, условия оформить в виде функций. Функции:
  * I) ```(x-50)**2 + (y-50)**2 < 50 **2```
  * II) ```math.fabs(x-50) < 25 and math.fabs(y-50) < 25```
  * III) ```math.fabs(x-50) + math.fabs(y-50) < 25```
  * IV) ```(x+y)%2 == 0```
  * V) ```(x/10 + y/10)%2 == 0```
* подумать, что далает каждая функция, проверить, насколько удалось догадаться
* посмотреть, как работают логические комбинации функций масок. Например:
  * IV or V
  * IV and V
  * IV and not V
  * etc
  



 
# Порция 5
* Питоновский модуль turtle:
  * команды: turtle.forward() - двигает курсор на заданое число пкселей вперед;
    * turtle.backward() - двигает курсор на заданное число пикселей назад;
    * turtle.left(), turtle.right() - поворачивает курсор налео или навпрво на заданый угол;
    * turtle.circle() - рисует окружность;
    * turtle.begin_fill(), turtle.end_fill() - заливка фигуры; 
    * turtle.color() - выбор цвета линии;
    * turtle.home() - возвращает курсор в точку старта, заданая точка старта имеет координаты (0, 0), но их можно изменить;
    * turtle.setposition() or .setpos() and .goto() - задают позицию для старта;
    * turtle.clear() - удаляет рисунок с экрана;
    * turtle.reset() - возвращает модуль к базовым настройкам и стирает рисунок.
Питоновская база - цикл for, рекурсии
* Пример программы: 
 1. выведет на экран прямоугольник с черной заливкой, длина каждой стороны прямоугольника - 50 пикселей
 ```python
   import turtle
   turtle.begin_fill()
   for t in range(4):
     turtle.forward(50)
     turtle.left(90)
   turtle.end_fill()
```
  2.  рекурсивная функция, которая построит сторону звёздочки Коха   
```python
def f(n,l):
    if n==0:
        turtle.forward(l)
        return
    f(n-1, l/3)
    turtle.left(60)
    f(n-1, l/3)
    turtle.right(120)
    f(n-1, l/3)
    turtle.left(60)
    f(n-1, l/3)
```

# Задачи
## Про списки и множества
Множество чисел задаётся строкой вида '1,3,5-15,20,21'. Сделать набор функций, позволяющих выполнять операции над множествами: объединение, пересечение, разность множеств, проверка равенства двух множеств. Результат также должен быть в этом формате. Например ls_intersect('7-12,13-20', '10-15') == '10-12,13-15'. ls - list set

## Чтобы разобраться с побитовыми операциями:
 * Распечатать степени двойки от 1ой до 10ой
 * Распечатать двоичные представления степеней двойки
 * По-применять побитовые операции << >> & | ^ к степеням двойки, посмотреть на двоичные представления получившихся результатов. По результатам
 экспериментов выписать таблицы истинности этих операций   
    
 # Геометрическая математика
 (x, y) = p - точка
 
 ## Как разобраться со скалярным и векторным произведениями
 * Написать функции:
   * sum(p1, p2) - покоординатно сложить точки
   * mul(p, k) - каждую координату точки p умножить на число k
   * line(p1, p2, c) - нарисовать отрезок цвета c, соединяющий точки p1, p2
   * shift(p, c) - от текущего положения сдвинуться в направлении p, нарисовать отрезок цвета c
 * Сложение векторов
   * Задать какие-то точки p1, p2
   * Найти p3 = sum(p1, p2)
   * Выполнить действия
     * home -> сдвинуться на p1, красный -> сдвинуться на p2, синий
     * home -> сдвинуться на p3, чёрный
  * Все точки отрезка:
    * $\alpha\cdot p_{11} + (1-\alpha)\cdot p_{12}$
    * Задать какие-нибудь p11, p12. Построить несколько точек по этой формуле, убедиться что все лежат на отрезке p11, p12.
  * Свойства скалярного и векторного произведений
    * определить функции:
      * dot((x1, y1), (x2, y2)) = x1*x2 + y1*y2
      * cross((x1, y1), (x2, y2)) = x1*y2 - x2*y1
    * Взять какие-нибудь x, y, построить вектора:
      * p = (x, y)
      * p1 = (-y, x)
      * p2 = p * k, где k - какое-нибудь число, например 3
    * Нарисовать вектора p, p1, p2 разными цветами. Осознать геометрический смысл умножения на число, замены местами координат с инверсией знака
    * Посчитать:
      * dot(p, p1)
      * cross(p, p1)
      * dot(p, p2)
      * cross(p, p2)
    * Осознать когда обнуляется скалярное произведение, когда - векторное
  * Применить все эти знания для нахождения точки пересечения двух отрезков:
    * Хотим написать функцию intersect(p11, p12, p21, p22) которая рисует отрезки p11-p12 и p21-p22, рассчитывает координаты точки пересечения и ставит туда отметку
    * Идея расчёта точки пересечения:
      * Утверждение раз: точка пересечения p = alpha * p11 + (1-alpha)*p12 лежит на  отрезке p11-p12
      * Утверждение два: нужно сделать alpha таким что векторное произведение p - p21 и p22 - p21 должно равняться нулю
      * По известной alpha находим точку - профит
 
 # Геометрический смысл скалярного произведения
   * Взяли произвольный вектор e11
   * По нему посчитали параллельный единичный вектор e1. Для этого:
     * определить функцию norm, находящую модуль вектора
     * умножить e1 на его обратную длину
   * e2 - повёрнутый против часовой стрелки на 90 градусов e1
   * Взяли произвольный вектор p
   * посчитали px = (p, e1), py = (p, e2)
   * Нарисовать вектора: p, p1 = e1 * px, p2 = e2 * py, p3 = p1 + p2
   * Построить картинки для нескольких значений e11, p. Дивиться результату.
   
 # Геометрический смысл знака векторного произведения
   * Нарисовать векторы p1 = (100, 10), p2 = (100, 20), p3 = (100, 30), p4 = (100, 40)
   * Посчитать векторные произведения пар этих векторов
   * Догадаться до геометрического смысла знака векторного произведения

 # Избранный: что такое матрица?
   * Тююплое решение: храним матрицу как тьюпл тюплов: ((a11, a12), (a21, a22))
   * Написать функцию rot(phi), генерирующую матрицу поворота на phi
   * Написать функцию mat_dot_vec(m, v), умножающую матрицу на вектор
   * mat - матрица поворота на 30 градусов. Взять "звездец" и перед рисованием точки к ней применить mat_dot_vec(mat, v). 
   * Хорошо подумать над тем, куда и почему повернулась фигурка
   * функция mat_dot_mat(m1, m2)
   * m1 - поворот на 30 градусов, m2 - поворот на 120, m3 - их произведение
   * построить "звездецы" с каждой из этих матриц. 
   
 # Матричные операции
   * create_matrix
   * matrix_mul(a, b)
   * matrix_vel_mul(m, v)
   * create_rot_mat(phi)
   * create_cw_rot_mat
   * create_ccw_rot_mat
   * solve_eq(A, Y)
   * Тестирование - переменожить матрицу прямого и обратного поворотов
   * Задача регрессии: [[1, 1, 1], [4, 2, 1], [9, 3, 1]], [1, 3, 6]
   
 # Черепашка в квадрате
   * В цикле прибавлять к (x, y) приращения (dx, dy). Каждый раз двигать черепашку в точку (x, y)
   * Если в следующий момент выходим из квадрата со стороной 100, меняем знак приращения dx или dy (по которому выходим)
 
 # Красивые картинки
   * Меняя phi от 0 до 2*pi гонять черепашку по точкам (200*sin(3*phi+sh), 200*sin(4*phi)). Менять sh, смотреть что изменится. Можно смотреть анимацию по sh.
   * Кривые в полярных координатах. phi от 0 до 10 phi. Гоняем по точкам (r * cos(phi), r * sin(phi))
     * r = 100
     * r = 5*phi
     * r = 1+cos(phi)
     * r = 2 + cos(phi) + sin(2*phi)
     
# Черепашка, огонь
  * dx, dy = 7, 3
  * x=0, y = 5
  * Пока y > 0: Двигаем черепашку в точку x,y. Учитываем приращения. dy -= 0.05
  
# Колодец
  * p1, p2, p3, p4 - вершины квадрата
  * 100 раз повторяем:
    * нарисовать квадрат p1, p2, p3, p4
    * q1 - 10% от p1 в сторону p2, аналогично - q2 - p2, p3; q3 - p3,p4; q4 - p4, p1
    * переложить новый квадрат из q в p
    
# Звездец
  * соединить отрезками точки (0, 100-p) и (p, 0) при p от 0 до 100
  * также отложить симметричные по осям отрезки
  
# Драконова ломаная
  * нарисовать ломаную, которая получится, если полоску бумаги согнуть несколько раз в одну сторону, а затем расправить так, чтобы все сгибы стали прямыми углами
 
# Солнышко
  * Используя функции черепашки up, down, circle, home, forward, heading, нарисовать солнышко (внутри круга ничего не рисуем)
  
# Фигуры Лиссажу
  * x = sin(a*phi + phi0), y=sin(b*phi)
  * a, b  - небольшие натуральные числа, phi0 - угол поворота фигуры
  * phi - меняется в цикле от 0 до 2*pi
  * Как по картинке восстановить числа a и b ?
  
# Нарисовать шахматную доску
  * copy-paste
  * структурировать используя функции
  * с помощью цикла (или циклов)
  
# Забор
  * Нарисовать доску с треугольной верхушкой. Угол наверху - 90 градусов
  * Поместить доску в цикл так, чтобы получился забор
  * Покрасить забор, чередуя красный и жёлтый цвета
   
 # Почитать
 
 * [Курс для школьников](http://informatics.mccme.ru/course/view.php?id=156)
 * [Курс на сайте mccme](http://informatics.mccme.ru/) - Тыкаем на "изучение языка программирования". Дальше выбираем один из разделов "ввод-вывод", "условный оператор", "операторы цикла" и т.д. Внутри заходим в раздел "Теоретический материал: Python"
 * [думать как програмёр. Черепашки](http://www.openbookproject.net/thinkcs/archive/python/thinkcspy3e_abandoned/ch03.html)
